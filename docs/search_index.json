[["index.html", "Manual administrador de Servidores Prefacio", " Manual administrador de Servidores Stephanie Hereira-Pacheco Prefacio Este libro comenzó como las notas tomadas de cursos y materiales para la administración de servidores en linux, aún en desarollo. Algunas de las ideas y notas fueron tomadas de los cursos de Udemy: Implementación de Servidores Linux (Módulo I) e Introducción a la Virtualización con VirtualBox "],["virtualización-e-instalación-de-redhatalmarockycentos.html", "1 VIRTUALIZACIÓN E INSTALACIÓN DE REDHAT/ALMA/ROCKY/CENTOS 1.1 Pasos para instalar distribución en máquina virtual", " 1 VIRTUALIZACIÓN E INSTALACIÓN DE REDHAT/ALMA/ROCKY/CENTOS 1.1 Pasos para instalar distribución en máquina virtual Instalar virtual box dependiendo del sistema operativo: https://www.virtualbox.org/wiki/Downloads Descargar la imagen iso de la distribución deseada, por ejemplo de alma linux: https://mirrors.almalinux.org/isos.html, centOS: http://isoredirect.centos.org/centos/7/isos/x86_64/ Dar en ‘New’ y agregar el archivo .iso luego seguir las instrucciones. Establecer RAM y especio para la máquina virtual, nombre y demases (para Alma escoger tipo Redhat64bit) Instalación de la distribución: Escoger Lenguuaje (Español/México) &gt; Continuar Destino (por defecto) Escoger red y nombre de sistema (enps03) &gt; Encender Hora y fecha del sistema (México Central) Contaseña ususario Root y crear ususario administrador Selección Software (Instalación mínima) Emepezar instalación y una vez adentro entrar con las credenciales del ususario administrador Tips: Evitar usar el Root user, preferiblemente desde el usuario administrador y con sudo El uso de virtualización para implementación de servidores Linux es conisderada como una buena práctica en términos de seguridad. "],["administración-de-procesos.html", "2 ADMINISTRACIÓN DE PROCESOS 2.1 Códigos para checar los procesos activos 2.2 CRON 2.3 Verificar nombre del sistema y modificarlo 2.4 Verificar y cambiar zona horaria", " 2 ADMINISTRACIÓN DE PROCESOS 2.1 Códigos para checar los procesos activos Listar procesos del actual usuario ps Listar todos los procesos del sistema ps -p Listar más detalles ps -ef | head -n 3 ## UID PID PPID C STIME TTY TIME CMD ## root 1 0 0 jun06 ? 00:00:57 /sbin/init splash ## root 2 0 0 jun06 ? 00:00:00 [kthreadd] Podemos distinguir pid (id del proceso), time (tiempo acumulado), CMD (comando o proceso), stime (tiempo de inicio), [] proceso llevado por kernel o sistema y en caso de no por los ususarios. Para terminar un proceso hay que identificar el pid o nombre del proceso y usar el comando kill, con el argumento g se forza el cierre: sudo kill 950 sudo kill g sshd 2.2 CRON Cron es un servicio para programar tareas: m h dom mon dow user command 17 * * * * root cd / &amp;&amp; run-parts –report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron 47 6 * * 7 root test -x /usr/sbin/anacron 52 6 1 * * root test -x /usr/sbin/anacron m : minutos (0-59) h : horas (0-23) dom : day of the month/ día del mes (1-31) mon : mes (1-12 or jan, feb, mar….) dow : day of the week/ días de la semana (0-6: sunday 0 or 7, or sun,mon, tue…) user: nombre de ususario command: comando a ser ejecutado Códigos para modificar tareas programadas: crontab -e #agregar cronta -r #remover crontab -l #listar 2.3 Verificar nombre del sistema y modificarlo Ver nombre del sistema hostname Cambiar nombre del sistema o servidor sudo hostname ctl set-hostname Nuevo_nombre sudo nano /etc/hostname Reiniciar sistema sudo reboot 2.4 Verificar y cambiar zona horaria Verificar zona horaria timedatectl ## Local time: mié 2023-06-14 16:30:26 CST ## Universal time: mié 2023-06-14 22:30:26 UTC ## RTC time: mié 2023-06-14 22:30:26 ## Time zone: America/Mexico_City (CST, -0600) ## System clock synchronized: yes ## systemd-timesyncd.service active: yes ## RTC in local TZ: no Buscar con grep zona horaria de preferencia timedatectl list-timezones | grep Mexico ## America/Mexico_City Cambiar zona horaria sudo timedatectl set-timezone América/Mexico_City "],["administración-remota-del-sistema.html", "3 ADMINISTRACIÓN REMOTA DEL SISTEMA 3.1 SSH 3.2 SCP (Secure copy protocol)", " 3 ADMINISTRACIÓN REMOTA DEL SISTEMA 3.1 SSH SSH o shell seguro es un protocolo de red que se implementa mediante un cliente/servidor y que tiene como objetivo crear canales de comunicación seguros mediante la aplicación de algoritmos de incriptación. SSH se opera en el puerto TCP 22. Usualmente al instalar Linux, Alma y CentOS se instala ssh, scp (copiado seguro de archivos) y sftp (transferencia segura de archivos). Sino, debe instalarse manualmente según el sistema o distribución. Para verificar que el protocolo esté activo: systemctl status sshd ## ● ssh.service - OpenBSD Secure Shell server ## Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled) ## Active: active (running) since Tue 2023-06-06 11:44:29 CST; 1 weeks 1 days ago ## Process: 13241 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS) ## Process: 13235 ExecReload=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS) ## Main PID: 1475 (sshd) ## Tasks: 1 (limit: 4915) ## CGroup: /system.slice/ssh.service ## └─1475 /usr/sbin/sshd -D ## ## jun 14 12:19:44 yendi systemd[1]: Reloading OpenBSD Secure Shell server. ## jun 14 12:19:44 yendi sshd[1475]: Received SIGHUP; restarting. ## jun 14 12:19:44 yendi systemd[1]: Reloaded OpenBSD Secure Shell server. ## jun 14 12:19:44 yendi sshd[1475]: Server listening on 0.0.0.0 port 22. ## jun 14 12:19:44 yendi sshd[1475]: Server listening on :: port 22. ## jun 14 12:19:44 yendi systemd[1]: Reloading OpenBSD Secure Shell server. ## jun 14 12:19:44 yendi sshd[1475]: Received SIGHUP; restarting. ## jun 14 12:19:44 yendi systemd[1]: Reloaded OpenBSD Secure Shell server. ## jun 14 12:19:44 yendi sshd[1475]: Server listening on 0.0.0.0 port 22. ## jun 14 12:19:44 yendi sshd[1475]: Server listening on :: port 22. Checar las conexciones y puertos sudo firewall-cmd --list-all Checar si los puertos están activos y escuchando ss -lntp ## State Recv-Q Send-Q Local Address:Port Peer Address:Port ## LISTEN 0 128 127.0.0.1:5939 0.0.0.0:* ## LISTEN 0 128 0.0.0.0:8787 0.0.0.0:* ## LISTEN 0 128 127.0.0.53%lo:53 0.0.0.0:* ## LISTEN 0 128 0.0.0.0:22 0.0.0.0:* ## LISTEN 0 5 127.0.0.1:631 0.0.0.0:* ## LISTEN 7 128 127.0.0.1:35037 0.0.0.0:* users:((&quot;rsession&quot;,pid=16827,fd=16),(&quot;sh&quot;,pid=8976,fd=16)) ## LISTEN 0 8 127.0.0.1:14623 0.0.0.0:* users:((&quot;rsession&quot;,pid=9539,fd=23),(&quot;ss&quot;,pid=3839,fd=23),(&quot;sh&quot;,pid=3838,fd=23)) ## LISTEN 0 8 127.0.0.1:23008 0.0.0.0:* users:((&quot;rsession&quot;,pid=16827,fd=24),(&quot;sh&quot;,pid=8976,fd=24)) ## LISTEN 0 128 127.0.0.1:26147 0.0.0.0:* users:((&quot;rsession&quot;,pid=9539,fd=16),(&quot;ss&quot;,pid=3839,fd=16),(&quot;sh&quot;,pid=3838,fd=16)) ## LISTEN 0 128 [::]:22 [::]:* ## LISTEN 0 5 [::1]:631 [::]:* Para habilitar funciones y permisos o demás configuraciones se puede editar el archivo de configuración con cualquier editor de texto (nano, vim, etc). Así luce el archivo: cat /etc/ssh/sshd_config ## # $OpenBSD: sshd_config,v 1.101 2017/03/14 07:19:07 djm Exp $ ## ## # This is the sshd server system-wide configuration file. See ## # sshd_config(5) for more information. ## ## # This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin ## ## # The strategy used for options in the default sshd_config shipped with ## # OpenSSH is to specify options with their default value where ## # possible, but leave them commented. Uncommented options override the ## # default value. ## ## Port 22 ## #AddressFamily any ## #ListenAddress 0.0.0.0 ## #ListenAddress :: ## ## #HostKey /etc/ssh/ssh_host_rsa_key ## #HostKey /etc/ssh/ssh_host_ecdsa_key ## #HostKey /etc/ssh/ssh_host_ed25519_key ## ## # Ciphers and keying ## #RekeyLimit default none ## ## # Logging ## #SyslogFacility AUTH ## #LogLevel INFO ## ## # Authentication: ## ## #LoginGraceTime 2m ## PermitRootLogin yes ## #StrictModes yes ## #MaxAuthTries 6 ## #MaxSessions 10 ## ## ## ## # Expect .ssh/authorized_keys2 to be disregarded by default in future. ## #AuthorizedKeysFile .ssh/authorized_keys ## ## #AuthorizedPrincipalsFile none ## ## #AuthorizedKeysCommand none ## #AuthorizedKeysCommandUser nobody ## ## # For this to work you will also need host keys in /etc/ssh/ssh_known_hosts ## #HostbasedAuthentication no ## # Change to yes if you don&#39;t trust ~/.ssh/known_hosts for ## # HostbasedAuthentication ## #IgnoreUserKnownHosts no ## # Don&#39;t read the user&#39;s ~/.rhosts and ~/.shosts files ## #IgnoreRhosts yes ## ## # To disable tunneled clear text passwords, change to no here! ## PasswordAuthentication yes ## #PermitEmptyPasswords no ## #PubkeyAuthentication yes ## ## # Change to yes to enable challenge-response passwords (beware issues with ## # some PAM modules and threads) ## ChallengeResponseAuthentication no ## ## # Kerberos options ## #KerberosAuthentication no ## #KerberosOrLocalPasswd yes ## #KerberosTicketCleanup yes ## #KerberosGetAFSToken no ## ## # GSSAPI options ## #GSSAPIAuthentication no ## #GSSAPICleanupCredentials yes ## #GSSAPIStrictAcceptorCheck yes ## #GSSAPIKeyExchange no ## ## # Set this to &#39;yes&#39; to enable PAM authentication, account processing, ## # and session processing. If this is enabled, PAM authentication will ## # be allowed through the ChallengeResponseAuthentication and ## # PasswordAuthentication. Depending on your PAM configuration, ## # PAM authentication via ChallengeResponseAuthentication may bypass ## # the setting of &quot;PermitRootLogin without-password&quot;. ## # If you just want the PAM account and session checks to run without ## # PAM authentication, then enable this but set PasswordAuthentication ## # and ChallengeResponseAuthentication to &#39;no&#39;. ## UsePAM yes ## ## #AllowAgentForwarding yes ## AllowTcpForwarding yes ## #GatewayPorts no ## X11Forwarding yes ## #X11DisplayOffset 10 ## #X11UseLocalhost yes ## #PermitTTY yes ## PrintMotd no ## #PrintLastLog yes ## #TCPKeepAlive yes ## #UseLogin no ## #PermitUserEnvironment no ## #Compression delayed ## #ClientAliveInterval 0 ## #ClientAliveCountMax 3 ## #UseDNS no ## #PidFile /var/run/sshd.pid ## #MaxStartups 10:30:100 ## #PermitTunnel no ## #ChrootDirectory none ## #VersionAddendum none ## ## # no default banner path ## #Banner none ## ## # Allow client to pass locale environment variables ## AcceptEnv LANG LC_* ## ## # override default of no subsystems ## Subsystem sftp /usr/lib/openssh/sftp-server ## ## # Example of overriding settings on a per-user basis ## #Match User anoncvs ## # X11Forwarding no ## # AllowTcpForwarding no ## # PermitTTY no ## # ForceCommand cvs server Al hacer cualquier cambio en este archivo debe reiniciarse el protocolo así: sudo systemctl restart sshd Para conectarse con un servidor debe colocarse ssh y la información del host o ip y el usuario: ssh usuario@hostname shh usuario@ip-address En caso de que la conexión sea através de otro puerto puede especificarse con el parámetro -p. 3.2 SCP (Secure copy protocol) Es un protocolo de transferencia de archivos de forma segura entre un host remoto y uno local, o entre dos ubicaciones remotas. Este funciona desde tu terminal sin haber iniciado o entrado a tu usuario en el servidor. Si estás conectado solo debes poner en tu terminal exit para que se desconecte. Para descargar un archivo desde un servidor o usuario remoto y colocarlo donde estás ubicado actualmente: scp ususario@hostname-or-ipaddres:~/ruta/directorio/archivo.txt . Para subir un archivo a un directorio de tu usuario en el servidor: scp archivo.txt ususario@hostname-or-ipaddres:~/ruta/directorio Para subir un directorio usar siempre -r recursivo: scp -r /ruta/directorio usuario@hostnale-or-ipaddres:/ruta/destino "],["administración-de-usuarios-grupos-y-permisos.html", "4 ADMINISTRACIÓN DE USUARIOS, GRUPOS Y PERMISOS 4.1 USUARIOS 4.2 PERMISOS EN LINUX", " 4 ADMINISTRACIÓN DE USUARIOS, GRUPOS Y PERMISOS 4.1 USUARIOS Existen varios comandos que nos permiten ubicarnos en qué usuario estamos ubicados e incluso en qué sistema operativo operamos y sus características. Por ejemplo este comando te dice que usuario eres: whoami ## yendi Si queremos saber información sobre nuestro sistema, versión, arquitectura y demás: uname -a ## Linux yendi 5.4.0-149-generic #166~18.04.1-Ubuntu SMP Fri Apr 21 16:42:44 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux Ahora, propiamente para conocer la información sobre nuestro usuario, en qué grupo nos encontramos y demás, usamos: id ## uid=1000(yendi) gid=1000(yendi) groups=1000(yendi),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare) uid= identificador de usuario (este será del número 1000 en adelante, los de 1000 para abajo están reservados para el sistema). gid= identificador del grupo principal, cada ususario que creamos puede encontrarse en varios grupos y al crearse por defecto se creará un grupo nuevo (también de 1000 en adelante) a no ser que se indique manualmente este id. groups= grupos a los que pertenece, dependiendo de esto tendrá o no permisos para algunas funciones del sistema. Por ejemplo, aquí el gripo adm indica que tiene privilegios administrativos y sudo que tiene permisos de superusuario, en el caso de CentOS o Alma (red-hat) el grupo wheel tiene privilegios especiales, como la capacidad de ejecutar comandos como superusuario o administrador del sistema. Para revisar los ususarios del sistema y los grupos usamos los siguientes códigos: tail /etc/passwd ## hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false ## geoclue:x:119:124::/var/lib/geoclue:/usr/sbin/nologin ## gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false ## gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false ## yendi:x:1000:1000:yendi,,,:/home/yendi:/bin/bash ## nvidia-persistenced:x:122:127:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin ## rstudio-server:x:999:999::/home/rstudio-server:/bin/sh ## lightdm:x:123:129:Light Display Manager:/var/lib/lightdm:/bin/false ## sshd:x:124:65534::/run/sshd:/usr/sbin/nologin ## dhcpd:x:125:131::/var/run:/usr/sbin/nologin En este vemos el id, gid, el directorio donde estará ubicado y el shell. Para ver los grupos y sus ususarios: tail /etc/group ## gdm:x:125: ## yendi:x:1000: ## sambashare:x:126:yendi ## nvidia-persistenced:x:127: ## rdma:x:128: ## rstudio-server:x:999: ## lightdm:x:129: ## nopasswdlogin:x:130: ## dhcpd:x:131: ## vboxusers:x:132: Hay otros archivos que se instalar con el sistema operativo ubicados en el home (no visibles, así que tienen un . antes del nombre) que pueden ser visualizados y/o modificados según se necesite. .bashrc: Este archivo se ejecuta cada vez que se inicia una nueva sesión de Bash. Contiene configuraciones y variables de entorno personalizadas para el usuario, como alias de comandos, variables de ambiente, configuraciones de color, etc. Cada usuario puede tener su propio archivo .bashrc en su directorio de inicio (~/.bashrc), lo que permite personalizar su entorno de shell. .bash_profile: Es similar a .bashrc, pero se ejecuta solo en el inicio de sesión del usuario (cuando se inicia sesión en el sistema). Se utiliza principalmente para configuraciones y tareas que deben realizarse una vez al iniciar sesión, como cargar variables de entorno, definir rutas, iniciar servicios, etc. Si existe el archivo .bash_profile, Bash lo ejecutará en lugar de .bashrc durante el inicio de sesión. .bash_logout: Este archivo se ejecuta cuando el usuario cierra la sesión. Puede contener comandos o tareas que deben realizarse antes de finalizar la sesión, como guardar el historial de comandos, limpiar temporales, notificar al usuario, etc. .bash_history: Es un archivo que registra el historial de comandos ejecutados por el usuario en el shell de Bash. Cada vez que se ejecuta un comando, se agrega una entrada al archivo .bash_history. Permite al usuario acceder al historial de comandos anteriores utilizando la tecla de flecha hacia arriba o mediante comandos como history. Estos archivos son parte del entorno de configuración y registro de Bash y pueden variar según el sistema operativo y la configuración del usuario. Proporcionan una manera de personalizar y controlar el comportamiento del shell de Bash para adaptarlo a las necesidades del usuario. 4.1.1 CREANDO USUARIOS NUEVOS Creando un usuario con los parámetros por defecto (uid asignado nuevo, gid asignado nuevo, bash y directorio en home con el mismo nombre). sudo useradd usuario1 Crear una contraseña para nuevo usuario sudo passwd usuario1 Creando un nuevo usuario pero con paráemtros establecidos asignadole un -u (userid), -g (gid) -m -d directorio de trabajo y -s un shell. sudo useradd -u 2000 -g 1000 -m -d /home/usuario2 -s /bin/bash usuario2 Crear un usuario para un proceso pero sin acceso. sudo useradd -s /sbin/nologin usuario3 Creando un usuario nuevo asignadolo a un grupo sudo useradd -G wheel usuario4 4.1.2 CREANDO UN NUEVO GRUPO Para crear un nuevo grupo: sudo groupadd nuevo_grupo Si se quiere cambiar el nombre de un grupo: sudo groupmod -n nuevo_nombre_grupo nombre_actual_grupo 4.1.3 MODIFICANDO CUENTAS DE USUARIO Cambiar el directorio de un usuario sudo usermod -m -d /home/user1 usuario1 Cambiar el shell de un usuario sudo usermod -s /sbin/nologin/ usuario2 Cambiar el login name de un usuario sudo usermod -l user2 usuario2 Agregar adicionalmente un usuario a un grupo ya definido (sin sacarlo de los grupos donde se encuentre) sudo usermod -a -G 1000 usuario6 Asignar un nuevo grupo principal a un usuario (ojo! el grupo se conservará pero el usuario ya no estará en ese grupo). sudo usermod -g 1000 usuario3 Eliminar un grupo (vacío) sudo groupdel usuario3 Eliminar un usuario sudo userdel usuario4 Remover un usuario de un grupo en específico sudo gpasswd -d usuario5 admon Con los codigos vistos previamente podemos estar seguros de los cambios previamente realizados: tail /cat/etc/passwd tail /cat/etc/group 4.2 PERMISOS EN LINUX Los permisos constan de una cadena de 9 caracteres, de los cuales, los 3 primeros son permisos de usuario actual, los 3 siguientes los permisos de los usuario pertenecientes al mismo grupo del usuario actual y los tres últimos los permisos para todos los usuarios. Este se hace con el código chmod . Los pérmisos pueden ser de: r = reading (lectura, apertura de archivos y directorios) w = writting (escritura, modficiación de archivos) x = executing (ejecución, poner en marcha programas) Existen dos métodos para administrar permisos: un método numérico y otro simbólico. 4.2.1 Método numérico r w x código numérico 0 0 0 0 0 0 1 1 0 1 0 2 0 1 1 3 1 0 0 4 1 0 1 5 1 1 0 6 1 1 1 7 Entonces si utilizas el número 7 estarás concediendo permiso de lectura, escritura y ejecución a quién lo desees. Ejemplo: chmod 777 . En este ejemplo estás dando permiso de los tres tipos a todos los usuarios (ususario actual, grupos y otros) del directorio actual. chmod 750 . En este ejemplo estás dando permiso de los tres tipos a todos los usuarios del directorio actual al usuario actual, permiso de lectura y ejecución a los del mismo grupo y ningún permiso a otro usuario externo. 4.2.2 Método simbólico Para este método se usará g para grupos, o para otros y a para todos , + si es permiso concedido y - si es denegado. Por ejemplo, queremos darle permiso del presente directorio a los ususario de migrupo, permisos de lectura y ejecución: chmod g+rx o darselo a otros: chmod o+rx o remover permisos a los de tu grupo y a otros: chmod g-rw,o-r o a todos: chmod a-rwx "],["administración-de-conectividad-de-red.html", "5 ADMINISTRACIÓN DE CONECTIVIDAD DE RED 5.1 NMCLI", " 5 ADMINISTRACIÓN DE CONECTIVIDAD DE RED Para probar tu conectividad utilizamos el código ping que hace una comprobación de errores de red como ip duplicada (servidor con otro equipo), interfaz de red desconectada, direccción DNS, entre otros. ping -c 3 www.google.com ## PING www.google.com(qro02s23-in-x04.1e100.net (2607:f8b0:4012:815::2004)) 56 data bytes ## 64 bytes from qro02s23-in-x04.1e100.net (2607:f8b0:4012:815::2004): icmp_seq=1 ttl=119 time=13.4 ms ## 64 bytes from qro02s23-in-x04.1e100.net (2607:f8b0:4012:815::2004): icmp_seq=2 ttl=119 time=12.9 ms ## 64 bytes from qro02s23-in-x04.1e100.net (2607:f8b0:4012:815::2004): icmp_seq=3 ttl=119 time=15.2 ms ## ## --- www.google.com ping statistics --- ## 3 packets transmitted, 3 received, 0% packet loss, time 2002ms ## rtt min/avg/max/mdev = 12.955/13.906/15.283/1.001 ms Hay códigos que nos servirán para identifcar nuestras conexiones de red e identificar nuestas ips. ip a s # ver todas ## 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 ## link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 ## inet 127.0.0.1/8 scope host lo ## valid_lft forever preferred_lft forever ## inet6 ::1/128 scope host ## valid_lft forever preferred_lft forever ## 2: enp0s31f6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 ## link/ether e8:6a:64:16:ae:37 brd ff:ff:ff:ff:ff:ff ## inet 192.168.1.73/24 brd 192.168.1.255 scope global dynamic noprefixroute enp0s31f6 ## valid_lft 71352sec preferred_lft 71352sec ## inet6 2806:10a6:d:f27e:110:7cb1:637e:8724/64 scope global temporary dynamic ## valid_lft 589753sec preferred_lft 70848sec ## inet6 2806:10a6:d:f27e:388c:9210:b998:66f4/64 scope global dynamic mngtmpaddr noprefixroute ## valid_lft 2591811sec preferred_lft 2591811sec ## inet6 fe80::808:14e8:e5de:acf/64 scope link noprefixroute ## valid_lft forever preferred_lft forever ## 3: wlp0s20f3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 ## link/ether 64:5d:86:a2:28:3a brd ff:ff:ff:ff:ff:ff ## inet 192.168.1.69/24 brd 192.168.1.255 scope global dynamic noprefixroute wlp0s20f3 ## valid_lft 71352sec preferred_lft 71352sec ## inet6 2806:10a6:d:f27e:284f:b83b:c86e:ede8/64 scope global temporary dynamic ## valid_lft 589754sec preferred_lft 70867sec ## inet6 2806:10a6:d:f27e:4f1c:273c:c651:4de7/64 scope global dynamic mngtmpaddr noprefixroute ## valid_lft 2591811sec preferred_lft 2591811sec ## inet6 fe80::f986:abc6:ff44:451a/64 scope link noprefixroute ## valid_lft forever preferred_lft forever Como se puede ver hay varios tipos de redes, puede ser de la conexión local, por wifi o por cable ethernet. ip a s enp0s31f6 # ver una en particular ## 2: enp0s31f6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 ## link/ether e8:6a:64:16:ae:37 brd ff:ff:ff:ff:ff:ff ## inet 192.168.1.73/24 brd 192.168.1.255 scope global dynamic noprefixroute enp0s31f6 ## valid_lft 71352sec preferred_lft 71352sec ## inet6 2806:10a6:d:f27e:110:7cb1:637e:8724/64 scope global temporary dynamic ## valid_lft 589753sec preferred_lft 70848sec ## inet6 2806:10a6:d:f27e:388c:9210:b998:66f4/64 scope global dynamic mngtmpaddr noprefixroute ## valid_lft 2591811sec preferred_lft 2591811sec ## inet6 fe80::808:14e8:e5de:acf/64 scope link noprefixroute ## valid_lft forever preferred_lft forever ip route show # ver ips ## default via 192.168.1.254 dev enp0s31f6 proto dhcp metric 100 ## default via 192.168.1.254 dev wlp0s20f3 proto dhcp metric 600 ## 169.254.0.0/16 dev wlp0s20f3 scope link metric 1000 ## 192.168.1.0/24 dev enp0s31f6 proto kernel scope link src 192.168.1.73 metric 100 ## 192.168.1.0/24 dev wlp0s20f3 proto kernel scope link src 192.168.1.69 metric 600 En caso de que se quiera desactivar o apagar una red en particular se puede hacer con los siguientes códigos: sudo ip link set enp0s31f6 down # apagar sudo ip link set enp0s31f6 up # encender Los archivos de configuración de ls redes se encuentran en: /etc/sysconfig/network-scripts, en ubuntu es /etc/NetworkManager/system-connections/ . Anteriormente estos archivos se modificaban para configurar las redes, pero ya no está recomendado ahora se recomiendan herramientas administradoras de redes, tales como: nmcli (cli), nmtui y control center (herramientas gráficas). 5.1 NMCLI Es un gestor de línea de comandos que usualmente ya viene instalado. Para revisar el estado de tus conexiones: nmcli device status ## DEVICE TYPE STATE CONNECTION ## enp0s31f6 ethernet connected enp0s31f6 ## wlp0s20f3 wifi connected INFINITUM3897 ## 70:5F:A3:36:BA:A3 bt disconnected -- ## 90:D4:73:10:84:9F bt disconnected -- ## lo loopback unmanaged -- Si se desea prender o apagar una conexión: nmcli con up enp0s31f6 #encender nmcli con down enp0s31f6 #apagar Para conocer más detalles de tus conexiones en particular puedes usar el código: nmcli con show enp0s31f6 ## connection.id: enp0s31f6 ## connection.uuid: abd3857e-d183-3bff-bf23-75fc0926a4ad ## connection.stable-id: -- ## connection.type: 802-3-ethernet ## connection.interface-name: -- ## connection.autoconnect: yes ## connection.autoconnect-priority: -999 ## connection.autoconnect-retries: -1 (default) ## connection.auth-retries: -1 ## connection.timestamp: 1686781607 ## connection.read-only: no ## connection.permissions: -- ## connection.zone: -- ## connection.master: -- ## connection.slave-type: -- ## connection.autoconnect-slaves: -1 (default) ## connection.secondaries: -- ## connection.gateway-ping-timeout: 0 ## connection.metered: unknown ## connection.lldp: default ## connection.mdns: -1 (default) ## 802-3-ethernet.port: -- ## 802-3-ethernet.speed: 0 ## 802-3-ethernet.duplex: -- ## 802-3-ethernet.auto-negotiate: no ## 802-3-ethernet.mac-address: E8:6A:64:16:AE:37 ## 802-3-ethernet.cloned-mac-address: -- ## 802-3-ethernet.generate-mac-address-mask:-- ## 802-3-ethernet.mac-address-blacklist: -- ## 802-3-ethernet.mtu: auto ## 802-3-ethernet.s390-subchannels: -- ## 802-3-ethernet.s390-nettype: -- ## 802-3-ethernet.s390-options: -- ## 802-3-ethernet.wake-on-lan: default ## 802-3-ethernet.wake-on-lan-password: -- ## ipv4.method: auto ## ipv4.dns: 8.8.8.8 ## ipv4.dns-search: -- ## ipv4.dns-options: &quot;&quot; ## ipv4.dns-priority: 0 ## ipv4.addresses: -- ## ipv4.gateway: -- ## ipv4.routes: -- ## ipv4.route-metric: -1 ## ipv4.route-table: 0 (unspec) ## ipv4.ignore-auto-routes: no ## ipv4.ignore-auto-dns: no ## ipv4.dhcp-client-id: -- ## ipv4.dhcp-timeout: 0 (default) ## ipv4.dhcp-send-hostname: yes ## ipv4.dhcp-hostname: -- ## ipv4.dhcp-fqdn: -- ## ipv4.never-default: no ## ipv4.may-fail: yes ## ipv4.dad-timeout: -1 (default) ## ipv6.method: auto ## ipv6.dns: -- ## ipv6.dns-search: -- ## ipv6.dns-options: &quot;&quot; ## ipv6.dns-priority: 0 ## ipv6.addresses: -- ## ipv6.gateway: -- ## ipv6.routes: -- ## ipv6.route-metric: -1 ## ipv6.route-table: 0 (unspec) ## ipv6.ignore-auto-routes: no ## ipv6.ignore-auto-dns: no ## ipv6.never-default: no ## ipv6.may-fail: yes ## ipv6.ip6-privacy: -1 (unknown) ## ipv6.addr-gen-mode: stable-privacy ## ipv6.dhcp-send-hostname: yes ## ipv6.dhcp-hostname: -- ## ipv6.token: -- ## proxy.method: none ## proxy.browser-only: no ## proxy.pac-url: -- ## proxy.pac-script: -- ## GENERAL.NAME: enp0s31f6 ## GENERAL.UUID: abd3857e-d183-3bff-bf23-75fc0926a4ad ## GENERAL.DEVICES: enp0s31f6 ## GENERAL.STATE: activated ## GENERAL.DEFAULT: yes ## GENERAL.DEFAULT6: yes ## GENERAL.SPEC-OBJECT: -- ## GENERAL.VPN: no ## GENERAL.DBUS-PATH: /org/freedesktop/NetworkManager/ActiveConnection/19 ## GENERAL.CON-PATH: /org/freedesktop/NetworkManager/Settings/7 ## GENERAL.ZONE: -- ## GENERAL.MASTER-PATH: -- ## IP4.ADDRESS[1]: 192.168.1.73/24 ## IP4.GATEWAY: 192.168.1.254 ## IP4.ROUTE[1]: dst = 0.0.0.0/0, nh = 192.168.1.254, mt = 100 ## IP4.ROUTE[2]: dst = 192.168.1.0/24, nh = 0.0.0.0, mt = 100 ## IP4.DNS[1]: 192.168.1.254 ## IP4.DNS[2]: 8.8.8.8 ## DHCP4.OPTION[1]: requested_subnet_mask = 1 ## DHCP4.OPTION[2]: subnet_mask = 255.255.255.0 ## DHCP4.OPTION[3]: requested_rfc3442_classless_static_routes = 1 ## DHCP4.OPTION[4]: domain_name_servers = 192.168.1.254 ## DHCP4.OPTION[5]: ip_address = 192.168.1.73 ## DHCP4.OPTION[6]: requested_static_routes = 1 ## DHCP4.OPTION[7]: dhcp_server_identifier = 192.168.1.254 ## DHCP4.OPTION[8]: requested_time_offset = 1 ## DHCP4.OPTION[9]: broadcast_address = 192.168.1.255 ## DHCP4.OPTION[10]: requested_interface_mtu = 1 ## DHCP4.OPTION[11]: requested_domain_name_servers = 1 ## DHCP4.OPTION[12]: dhcp_message_type = 5 ## DHCP4.OPTION[13]: requested_broadcast_address = 1 ## DHCP4.OPTION[14]: routers = 192.168.1.254 ## DHCP4.OPTION[15]: unknown_120 = 0:6:76:69:6d:73:2d:68:6:74:65:6c:6d:65:78:3:63:6f:6d:0 ## DHCP4.OPTION[16]: requested_domain_name = 1 ## DHCP4.OPTION[17]: requested_routers = 1 ## DHCP4.OPTION[18]: expiry = 1686853184 ## DHCP4.OPTION[19]: host_name = yendi ## DHCP4.OPTION[20]: requested_netbios_scope = 1 ## DHCP4.OPTION[21]: requested_wpad = 1 ## DHCP4.OPTION[22]: requested_ms_classless_static_routes = 1 ## DHCP4.OPTION[23]: tftp_server_name = tftp://0.0.0.0 ## DHCP4.OPTION[24]: requested_netbios_name_servers = 1 ## DHCP4.OPTION[25]: network_number = 192.168.1.0 ## DHCP4.OPTION[26]: requested_domain_search = 1 ## DHCP4.OPTION[27]: next_server = 0.0.0.0 ## DHCP4.OPTION[28]: requested_ntp_servers = 1 ## DHCP4.OPTION[29]: vendor_encapsulated_options = 1:4:43:54:43:30 ## DHCP4.OPTION[30]: requested_host_name = 1 ## DHCP4.OPTION[31]: dhcp_lease_time = 86400 ## DHCP4.OPTION[32]: vendor_unknown_3561 = 4:6:30:30:45:30:34:43:5:c:30:36:30:33:37:30:38:38:32:37:31:31:6:3:49:47:44 ## IP6.ADDRESS[1]: 2806:10a6:d:f27e:110:7cb1:637e:8724/64 ## IP6.ADDRESS[2]: 2806:10a6:d:f27e:388c:9210:b998:66f4/64 ## IP6.ADDRESS[3]: fe80::808:14e8:e5de:acf/64 ## IP6.GATEWAY: fe80::1 ## IP6.ROUTE[1]: dst = 2806:10a6:d:f27e::/64, nh = ::, mt = 100 ## IP6.ROUTE[2]: dst = ::/0, nh = fe80::1, mt = 100 ## IP6.ROUTE[3]: dst = fe80::/64, nh = ::, mt = 256 ## IP6.ROUTE[4]: dst = fe80::/64, nh = ::, mt = 100 ## IP6.DNS[1]: 2806:10a8:ffff:2::e ## IP6.DNS[2]: 2806:10a0:ffff:2::e ## DHCP6.OPTION[1]: requested_dhcp6_domain_search = 1 ## DHCP6.OPTION[2]: dhcp6_name_servers = 2806:10a8:ffff:2::e 2806:10a0:ffff:2::e ## DHCP6.OPTION[3]: dhcp6_server_id = 0:1:0:1:2c:13:70:2c:dc:8d:b7:47:57:60 ## DHCP6.OPTION[4]: requested_dhcp6_client_id = 1 ## DHCP6.OPTION[5]: requested_dhcp6_name_servers = 1 ## DHCP6.OPTION[6]: dhcp6_client_id = 0:4:85:44:5a:8e:a1:7a:cd:38:81:b3:fe:da:de:2b:ba:f7 Si se quiere modificar algunos de estos parámetros detallados anteriormente, por ejemeplo: sudo nmcli con modify enp0s31f6 ipv4.address 192.1.110/24 sudo nmcli con modify enp0s31f6 ipv4.gateway 192.168.11 sudo nmcli con modify enp0s31f6 ipv4.dns 8.8.8.8 sudo nmcli con modify enp0s31f6 ipv4.method manual Luego de hacer estos cambios se debe apagar y prender como el paso anterior: nmcli con down enp0s31f6 #apagar nmcli con up enp0s31f6 #encender "],["administración-de-paquetes.html", "6 ADMINISTRACIÓN DE PAQUETES", " 6 ADMINISTRACIÓN DE PAQUETES Dependiendo de la distribución es el administrador de paquetes. Para ubuntu es usualmente apt, para alma y red-hat es dnfpara centOS era yum pero también puede instalarse el dnf. Los paquetes a descargar en centOS y redhat vienen en extensión .rpm en ubuntu en .deb. DNF viene instalado por defecto en alma linux y centOS actualmente también. “Dnf” es una herramienta de línea de comandos utilizada para instalar, actualizar y administrar paquetes en sistemas basados en RPM, como CentOS y AlmaLinux. Puedes usar el comando “dnf” para buscar paquetes, instalar software, actualizar el sistema y realizar otras operaciones relacionadas con la gestión de paquetes. Hay dos tipos de paquetes: BaseOS: El paquete BaseOS (Sistema Operativo Base) contiene los componentes esenciales del sistema operativo, como el kernel, las utilidades básicas del sistema y las bibliotecas fundamentales. Estos paquetes proporcionan la funcionalidad básica del sistema y son necesarios para su funcionamiento. El paquete BaseOS se actualiza con menos frecuencia que el paquete AppStream y está diseñado para ser estable y confiable. AppStream: El paquete AppStream (Flujo de Aplicaciones) contiene una amplia variedad de paquetes de aplicaciones y software adicional que se pueden instalar en el sistema. Estos paquetes incluyen aplicaciones de escritorio, bibliotecas adicionales, controladores de dispositivos, herramientas de desarrollo y otros complementos de software. El paquete AppStream se actualiza con más frecuencia y permite a los usuarios acceder a un conjunto más amplio de aplicaciones y funcionalidades. En otras palabras son paquetes adicionales o extras. Para consultar los paqutes instalados debemos usar el código: dnf list installed | head ## bash: dnf: command not found Para ver que paquetes están disponibles hay que consultar como superusuario así: sudo dnf list available Para consultar uno en particular igual con superusuario: sudo dnf list tree Para actualizar se puede usar: sudo dnf update sudo dnf upgrade “sudo dnf update” actualiza todos los paquetes a sus últimas versiones disponibles, mientras que “sudo dnf upgrade” también realiza una limpieza al eliminar paquetes obsoletos o no necesarios en el proceso de actualización. Ambos comandos son útiles para mantener el sistema actualizado y seguro. Para buscar o consultar sobre un paquete en particular poremos usar los siguientes códigos: sudo dnf search php sudo dnf info php Para instalar o desintalar un paquete, usamos: sudo dnf install tar sudo dnfinstall -y tar # para evitar preguntas sudo dnf remove tar -y Y para actualizar un solo paquete en particular igual update o upgrade: sudo dnf update tar # se actuliza nueva versión y se almacena el viejo sudo dnf upgrade tar # se actualiza nueva versión y se elemina la anterior "],["administración-de-firewall.html", "7 ADMINISTRACIÓN DE FIREWALL", " 7 ADMINISTRACIÓN DE FIREWALL systemctl es una herramienta de línea de comandos utilizada en sistemas Linux que se adhieren al estándar de inicio y administración del sistema systemd. systemd es un sistema init ampliamente adoptado en distribuciones modernas de Linux, como Ubuntu, CentOS, Fedora, entre otras. systemctl se utiliza para controlar el sistema init y gestionar los servicios del sistema, permitiendo iniciar, detener, reiniciar, habilitar o deshabilitar servicios. También proporciona información sobre el estado de los servicios y registros asociados. Con systemctl, puedes administrar tanto servicios del sistema como servicios de usuario. systemctl puede usarse para verificar y administrar el firewall. Un firewall, en el contexto de la informática y la seguridad de redes, es una barrera de seguridad que controla y regula el tráfico de red entre redes o sistemas. Su función principal es proteger los sistemas y redes de posibles amenazas provenientes de redes externas o internas no confiables. Algunos códigos para checar el estado del firewall y reiniciarlo, son: sudo systemctl status firewalld sudo systemctl restart firewalld firewall-cmd es una interfaz de línea de comandos utilizada para administrar y configurar el firewall en sistemas operativos basados en Linux que utilizan el firewall firewalld. Algunos códigos para ver tus firewalls son: sudo firewall-cmd --list-all sudo firewall-cmd --get-services | grep ssh # para ver si está Verificar quienes están conectados por ssh: ss | grep -i ssh Para modificar algunos parámetros igual se usa firewall-cmd, algunos ejemplos: sudo firewall-cmd --permanent --remove-service=ssh # remover ssh sudo firewall-cmd --permanent --add-rich-rule=&#39;rule family ipv4 source addres=192.168.1.108, service name = ssh accept&#39; # hacer que sólo este equipo puede conectarse por ssh "],["administración-de-servicios.html", "8 ADMINISTRACIÓN DE SERVICIOS", " 8 ADMINISTRACIÓN DE SERVICIOS Un servicio es un programa que se ejecuta de manera continua y permanente por lo general en segundo palno y tiene una funcionalidad específica. Estos son algunos ejemplos de algunos servicios Internos y de red: NetworkManager: interno: Controla interfaces y conexiones de red sshd : red: administración remota httpd : red : Servidor web crond : interno : Programas ejecución de tareas firewalld : interno : Administrar firewalld del sistema mysql : red : Administración de bases de datos systemctles un componente del sistema que administra los servicios combinado con otro parámetro como start, stop, restart, reolad, enable, disable y status, nos permitirá iniciar, encender, apagar y permitir un servicio. Para verificar cuales están corriendose actualmente en el sistem: systemctl list-units --type=service --state=running Si se hace algún cambio o modificación como en el capítulo anterior debe reiniciarse el sistema para que se efectúen los cambios. sudo systemctl restart sshd Algunos ejemplos para la instalación de algunos de algunos servicios externos: 8.0.1 APACHE sudo dnf install httpd sudo systemctl start httpd sudo systemctl enable httpd sudo systemctl status httpd 8.0.2 MARIA DB sudo dnf install mariadb-server sudo systemctl start mariadb sudo systemctl enable mariadb sudo systemctl status mariadb sudo firewalld-cmd --permanent --add-port=3300/tcp -zone=public sudo firewalld-cmd --reload mysql_secure_installation # y seguir las instrucciones "],["extras.html", "9 EXTRAS 9.1 CONCEPTOS CLAVES 9.2 EDITOR DE TEXTOS vi", " 9 EXTRAS 9.1 CONCEPTOS CLAVES 9.1.1 LINUX Y DISTRIBUCIONES Linux es un sistema operativo de código abierto basado en Unix. Fue desarrollado originalmente por Linus Torvalds en 1991 y se ha convertido en uno de los sistemas operativos más populares y utilizados en el mundo. Linux se caracteriza por ser modular, flexible y altamente personalizable. Es conocido por su estabilidad, seguridad y rendimiento, y se utiliza en una amplia variedad de dispositivos y entornos, desde servidores y estaciones de trabajo hasta dispositivos móviles y sistemas integrados. Una distribución de Linux, también conocida como “distro”, es una versión específica de Linux que incluye el núcleo de Linux, junto con una selección de aplicaciones, herramientas y paquetes de software adicionales. Las distribuciones de Linux se crean para satisfacer diferentes necesidades y preferencias de los usuarios, y pueden variar en términos de objetivos, enfoques de administración, conjuntos de aplicaciones, entornos de escritorio y soporte. Algunas de las distribuciones de Linux más conocidas son Ubuntu, Fedora, Debian, CentOS, Arch Linux, openSUSE, entre otras. Cada distribución tiene sus propias características, filosofía y comunidad de usuarios, lo que permite a los usuarios elegir la distribución que mejor se adapte a sus necesidades y preferencias. Para servidores se usan con frecuencia las distribuciones de Debian, RHEL (Redhat), Ubuntu y antes de ser descontinuado centOS. Las distribuciones gratuitas similares a RHEL son Alma y Rocky que funcionan muy similar y siguen las actualizaciones. 9.1.2 VIRTUALIZACIÓN El uso de la virtualización para la implementación de servidores Linux en considerada como una buena práctica en términos de seguridad ya que antes de ser aplicadas las configuraciones se pueden probar en una máquina virtual. 9.1.3 REDES Y TIPOS DE CONEXIONES 9.1.3.1 NAT Las máquinas virtuales tienen acceso a redes externas al sistema anfitrión mediante el uso de NAT (Network address translation). Una IP de una red interna se traslada a una red de una IP externa para poder obtener comunicación hacia al exterior. Es una técnica utilizada en enrutadores o firewalls para permitir que varios dispositivos en una red privada compartan una única dirección IP pública. Cuando un dispositivo de la red privada envía una solicitud al exterior, la dirección IP de origen se reemplaza por la dirección IP pública del enrutador o firewall. De esta manera, se oculta la estructura de la red privada y se permite que múltiples dispositivos compartan la misma dirección IP pública. 9.1.3.2 Red NAT En el contexto de las máquinas virtuales, una red NAT es una configuración de red virtual en la que la máquina virtual tiene acceso a una red externa a través de un enrutador virtual. El enrutador virtual realiza la traducción de direcciones de red, similar a NAT en un enrutador físico. La máquina virtual se conecta a la red externa utilizando una dirección IP virtual proporcionada por el enrutador virtual. Esto permite que la máquina virtual se comunique con recursos externos, como Internet, sin exponer directamente su dirección IP privada al exterior. En las máquinas debe virtuales para usar esta debe primero darse de alta y luedo dar Restart y poner diferentes IPs. 9.1.3.3 Puente (Bridge) Se comportan como equipos físicos que se conectan al switch. Se integran como equipos adicionales dentro de la red local. La máquina se inegra a la red con servicios de mediano volumen. Esta configuración permite que la máquina virtual se comporte como si estuviera conectada directamente a la red física, lo que facilita la comunicación con otros dispositivos en la red. 9.1.3.4 Solo anfitrión (Host-only) En esta configuración, la máquina virtual se conecta únicamente a una red virtual interna que existe solo entre el host y las máquinas virtuales. Las máquinas virtuales pueden comunicarse entre sí y con el host, pero no tienen acceso directo a la red física externa ni a otros dispositivos en la red. Esto proporciona un entorno de red aislado y seguro para las máquinas virtuales. No necesita salida al internet y ocupa pocos recursos. 9.1.3.5 Red interna (Internal): En esta configuración, las máquinas virtuales se conectan a una red virtual interna que existe solo entre ellas, sin acceso a la red física del host ni a dispositivos externos. Las máquinas virtuales en la misma red interna pueden comunicarse entre sí, pero no pueden comunicarse con el host ni con otros dispositivos externos. 9.1.4 PORT FORWARDING La combinación de NAT y Port forwarding es muy usado en empresas y tiene beneficios de seguridad y administración. Una red NAT como lo vimos anteriormente, es una técnica mediante la cual un equipo en red facilita el acceso a internet a un grupo de equipos, intercambiando de manera temporal una IP privada por una IP pública. Esto se utiliza ampliamente en routers y firewalls tipo UTM. Desde afuera estas máquinas no son visibles, cualquier cosa que haga un usuario será a cargo de administador. El port forwarding es un mecanismo o técnica para aislar sistemas en red, por lo general servidores, de forma tal que el acceso de los servicios implementados requiere de un sistema intermediario. Este último equipo mantiene una relación de direcciones IP y puertos a los cuales deberán enviar las peticiones de servicio que él mismo recibe. Port forwarding (reenvío de puertos) es una técnica que permite redirigir el tráfico de red entrante desde un puerto específico de un dispositivo de red hacia otro dispositivo o servicio en la red local. Cuando un dispositivo recibe datos de red, generalmente utiliza puertos específicos para distinguir diferentes servicios o aplicaciones que se ejecutan en él. El reenvío de puertos permite que los datos entrantes que llegan a un puerto específico sean redirigidos hacia otro dispositivo o servicio en la red local, incluso si ese dispositivo se encuentra detrás de un enrutador o firewall. El reenvío de puertos es útil en escenarios como acceder a servicios en una red local desde Internet, permitir conexiones remotas a un servidor o configurar aplicaciones que requieren puertos específicos para funcionar correctamente. 9.2 EDITOR DE TEXTOS vi vi es un editor de texto muy común en sistemas Unix y se utiliza para editar y crear archivos de texto en la línea de comandos. Sin embargo, ten en cuenta que en algunas distribuciones de Linux, vi puede ser una versión básica del editor y es posible que prefieras utilizar un editor de texto más avanzado como vim (Vi Improved). Puedes instalar vim en Ubuntu y AlmaLinux utilizando el administrador de paquetes de la distribución correspondiente. Si deseas verificar si vi está instalado en tu sistema, puedes ejecutar el siguiente comando en la terminal: vi --version ## VIM - Vi IMproved 8.0 (2016 Sep 12, compiled Apr 18 2023 09:20:34) ## Included patches: 1-1453, 3625, 3669, 3741 ## Modified by pkg-vim-maintainers@lists.alioth.debian.org ## Compiled by pkg-vim-maintainers@lists.alioth.debian.org ## Huge version without GUI. Features included (+) or not (-): ## +acl +farsi +mouse_sgr -tag_any_white ## +arabic +file_in_path -mouse_sysmouse -tcl ## +autocmd +find_in_path +mouse_urxvt +termguicolors ## -autoservername +float +mouse_xterm +terminal ## -balloon_eval +folding +multi_byte +terminfo ## +balloon_eval_term -footer +multi_lang +termresponse ## -browse +fork() -mzscheme +textobjects ## ++builtin_terms +gettext +netbeans_intg +timers ## +byte_offset -hangul_input +num64 +title ## +channel +iconv +packages -toolbar ## +cindent +insert_expand +path_extra +user_commands ## -clientserver +job -perl +vertsplit ## -clipboard +jumplist +persistent_undo +virtualedit ## +cmdline_compl +keymap +postscript +visual ## +cmdline_hist +lambda +printer +visualextra ## +cmdline_info +langmap +profile +viminfo ## +comments +libcall -python +vreplace ## +conceal +linebreak +python3 +wildignore ## +cryptv +lispindent +quickfix +wildmenu ## +cscope +listcmds +reltime +windows ## +cursorbind +localmap +rightleft +writebackup ## +cursorshape -lua -ruby -X11 ## +dialog_con +menu +scrollbind -xfontset ## +diff +mksession +signs -xim ## +digraphs +modify_fname +smartindent -xpm ## -dnd +mouse +startuptime -xsmp ## -ebcdic -mouseshape +statusline -xterm_clipboard ## +emacs_tags +mouse_dec -sun_workshop -xterm_save ## +eval +mouse_gpm +syntax ## +ex_extra -mouse_jsbterm +tag_binary ## +extra_search +mouse_netterm +tag_old_static ## system vimrc file: &quot;$VIM/vimrc&quot; ## user vimrc file: &quot;$HOME/.vimrc&quot; ## 2nd user vimrc file: &quot;~/.vim/vimrc&quot; ## user exrc file: &quot;$HOME/.exrc&quot; ## defaults file: &quot;$VIMRUNTIME/defaults.vim&quot; ## fall-back for $VIM: &quot;/usr/share/vim&quot; ## Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H -Wdate-time -g -O2 -fdebug-prefix-map=/build/vim-bW1j6S/vim-8.0.1453=. -fstack-protector-strong -Wformat -Werror=format-security -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 ## Linking: gcc -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -o vim -lm -ltinfo -lnsl -lselinux -lacl -lattr -lgpm -ldl -L/usr/lib/python3.6/config-3.6m-x86_64-linux-gnu -lpython3.6m -lpthread -ldl -lutil -lm Antes de acceder a algunas de estas opciones recuerde debe presionar la tecla ESC. Opciones: i : insertar texto en posición actual a : insertar texto en posición siguiente o : insertar una nueva línea de la posición actual O : insertar una nueva línea sobre la posición actual dd : eliminar línea actual yy : copiar línea actual p : pegar texto cw : reemplazar palabra x : eliminar caracter primero u : deshacer Luego de presionar ESC + :, podemos tener más opciones, tales como: :w = guardar :q = salir de vi :wq = guardar y salir :q’ = salir sin guardar :set nu/nonu = mostrar o no la numeración de las líneas /palabra = buscar “palabra” en texto :g = reemplazar o eliminar (:g/word/s//WORD/g, g/word/d) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
