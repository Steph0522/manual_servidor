[["index.html", "Manual administrador de Servidores Prefacio", " Manual administrador de Servidores Stephanie Hereira-Pacheco Prefacio Este libro comenzó como las notas tomadas de cursos y materiales para la administración de servidores en linux, aún en desarollo. "],["virtualización-e-instalación-de-redhatalmarockycentos.html", "1 VIRTUALIZACIÓN E INSTALACIÓN DE REDHAT/ALMA/ROCKY/CENTOS 1.1 Pasos para instalar distribución en máquina virtual", " 1 VIRTUALIZACIÓN E INSTALACIÓN DE REDHAT/ALMA/ROCKY/CENTOS 1.1 Pasos para instalar distribución en máquina virtual Instalar virtual box dependiendo del sistema operativo: https://www.virtualbox.org/wiki/Downloads Descargar la imagen iso de la distribución deseada, por ejemplo de alma linux: https://mirrors.almalinux.org/isos.html, centOS: http://isoredirect.centos.org/centos/7/isos/x86_64/ Dar en ‘New’ y agregar el archivo .iso luego seguir las instrucciones. Establecer RAM y especio para la máquina virtual, nombre y demases (para Alma escoger tipo Redhat64bit) Instalación de la distribución: Escoger Lenguuaje (Español/México) &gt; Continuar Destino (por defecto) Escoger red y nombre de sistema (enps03) &gt; Encender Hora y fecha del sistema (México Central) Contaseña ususario Root y crear ususario administrador Selección Software (Instalación mínima) Emepezar instalación y una vez adentro entrar con las credenciales del ususario administrador Tips: Evitar usar el Root user, preferiblemente desde el usuario administrador y con sudo El uso de virtualización para implementación de servidores Linux es conisderada como una buena práctica en términos de seguridad. "],["administración-de-procesos.html", "2 ADMINISTRACIÓN DE PROCESOS 2.1 Códigos para checar los procesos activos 2.2 CRON 2.3 Verificar nombre del sistema y modificarlo 2.4 Verificar y cambiar zona horaria", " 2 ADMINISTRACIÓN DE PROCESOS 2.1 Códigos para checar los procesos activos Listar procesos del actual usuario ps Listar todos los procesos del sistema ps -p Listar más detalles ps -ef | head -n 3 ## UID PID PPID C STIME TTY TIME CMD ## root 1 0 0 jun06 ? 00:00:55 /sbin/init splash ## root 2 0 0 jun06 ? 00:00:00 [kthreadd] Podemos distinguir pid (id del proceso), time (tiempo acumulado), CMD (comando o proceso), stime (tiempo de inicio), [] proceso llevado por kernel o sistema y en caso de no por los ususarios. Para terminar un proceso hay que identificar el pid o nombre del proceso y usar el comando kill, con el argumento g se forza el cierre: sudo kill 950 sudo kill g sshd 2.2 CRON Cron es un servicio para programar tareas: m h dom mon dow user command 17 * * * * root cd / &amp;&amp; run-parts –report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron 47 6 * * 7 root test -x /usr/sbin/anacron 52 6 1 * * root test -x /usr/sbin/anacron m : minutos (0-59) h : horas (0-23) dom : day of the month/ día del mes (1-31) mon : mes (1-12 or jan, feb, mar….) dow : day of the week/ días de la semana (0-6: sunday 0 or 7, or sun,mon, tue…) user: nombre de ususario command: comando a ser ejecutado Códigos para modificar tareas programadas: crontab -e #agregar cronta -r #remover crontab -l #listar 2.3 Verificar nombre del sistema y modificarlo Ver nombre del sistema hostname Cambiar nombre del sistema o servidor sudo hostname ctl set-hostname Nuevo_nombre sudo nano /etc/hostname Reiniciar sistema sudo reboot 2.4 Verificar y cambiar zona horaria Verificar zona horaria timedatectl ## Local time: lun 2023-06-12 23:44:04 CST ## Universal time: mar 2023-06-13 05:44:04 UTC ## RTC time: mar 2023-06-13 05:44:04 ## Time zone: America/Mexico_City (CST, -0600) ## System clock synchronized: yes ## systemd-timesyncd.service active: yes ## RTC in local TZ: no Buscar con grep zona horaria de preferencia timedatectl list-timezones | grep Mexico ## America/Mexico_City Cambiar zona horaria sudo timedatectl set-timezone América/Mexico_City "],["administración-remota-del-sistema.html", "3 ADMINISTRACIÓN REMOTA DEL SISTEMA 3.1 SSH 3.2 SCP (Secure copy protocol)", " 3 ADMINISTRACIÓN REMOTA DEL SISTEMA 3.1 SSH SSH o shell seguro es un protocolo de red que se implementa mediante un cliente/servidor y que tiene como objetivo crear canales de comunicación seguros mediante la aplicación de algoritmos de incriptación. SSH se opera en el puerto TCP 22. Usualmente al instalar Linux, Alma y CentOS se instala ssh, scp (copiado seguro de archivos) y sftp (transferencia segura de archivos). Sino, debe instalarse manualmente según el sistema o distribución. Para verificar que el protocolo esté activo: systemctl status sshd ## ● ssh.service - OpenBSD Secure Shell server ## Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled) ## Active: active (running) since Tue 2023-06-06 11:44:29 CST; 6 days ago ## Main PID: 1475 (sshd) ## Tasks: 1 (limit: 4915) ## CGroup: /system.slice/ssh.service ## └─1475 /usr/sbin/sshd -D ## ## jun 12 14:04:26 yendi sshd[885]: pam_unix(sshd:session): session closed for user yendi ## jun 12 15:47:50 yendi sshd[8041]: Accepted password for yendi from 192.168.1.74 port 53466 ssh2 ## jun 12 15:47:50 yendi sshd[8041]: pam_unix(sshd:session): session opened for user yendi by (uid=0) ## jun 12 15:47:50 yendi sshd[8041]: pam_unix(sshd:session): session closed for user yendi ## jun 12 15:48:01 yendi sshd[8176]: Accepted password for yendi from 192.168.1.74 port 53468 ssh2 ## jun 12 15:48:01 yendi sshd[8176]: pam_unix(sshd:session): session opened for user yendi by (uid=0) ## jun 12 15:48:01 yendi sshd[8176]: pam_unix(sshd:session): session closed for user yendi ## jun 12 18:20:16 yendi sshd[25401]: Accepted password for yendi from 192.168.1.72 port 54948 ssh2 ## jun 12 18:20:16 yendi sshd[25401]: pam_unix(sshd:session): session opened for user yendi by (uid=0) ## jun 12 18:20:16 yendi sshd[25401]: pam_unix(sshd:session): session closed for user yendi Checar las conexciones y puertos sudo firewall-cmd --list-all Checar si los puertos están activos y escuchando ss -lntp ## State Recv-Q Send-Q Local Address:Port Peer Address:Port ## LISTEN 0 128 127.0.0.1:5939 0.0.0.0:* ## LISTEN 0 128 0.0.0.0:8787 0.0.0.0:* ## LISTEN 0 128 127.0.0.53%lo:53 0.0.0.0:* ## LISTEN 0 128 0.0.0.0:22 0.0.0.0:* ## LISTEN 0 5 127.0.0.1:631 0.0.0.0:* ## LISTEN 7 128 127.0.0.1:35037 0.0.0.0:* users:((&quot;rsession&quot;,pid=16827,fd=16),(&quot;sh&quot;,pid=8976,fd=16)) ## LISTEN 0 8 127.0.0.1:14623 0.0.0.0:* users:((&quot;ss&quot;,pid=19878,fd=23),(&quot;sh&quot;,pid=19877,fd=23),(&quot;rsession&quot;,pid=9539,fd=23)) ## LISTEN 0 8 127.0.0.1:23008 0.0.0.0:* users:((&quot;rsession&quot;,pid=16827,fd=24),(&quot;sh&quot;,pid=8976,fd=24)) ## LISTEN 0 128 127.0.0.1:26147 0.0.0.0:* users:((&quot;ss&quot;,pid=19878,fd=16),(&quot;sh&quot;,pid=19877,fd=16),(&quot;rsession&quot;,pid=9539,fd=16)) ## LISTEN 0 128 [::]:22 [::]:* ## LISTEN 0 5 [::1]:631 [::]:* Para habilitar funciones y permisos o demás configuraciones se puede editar el archivo de configuración con cualquier editor de texto (nano, vim, etc). Así luce el archivo: cat /etc/ssh/sshd_config ## # $OpenBSD: sshd_config,v 1.101 2017/03/14 07:19:07 djm Exp $ ## ## # This is the sshd server system-wide configuration file. See ## # sshd_config(5) for more information. ## ## # This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin ## ## # The strategy used for options in the default sshd_config shipped with ## # OpenSSH is to specify options with their default value where ## # possible, but leave them commented. Uncommented options override the ## # default value. ## ## Port 22 ## #AddressFamily any ## #ListenAddress 0.0.0.0 ## #ListenAddress :: ## ## #HostKey /etc/ssh/ssh_host_rsa_key ## #HostKey /etc/ssh/ssh_host_ecdsa_key ## #HostKey /etc/ssh/ssh_host_ed25519_key ## ## # Ciphers and keying ## #RekeyLimit default none ## ## # Logging ## #SyslogFacility AUTH ## #LogLevel INFO ## ## # Authentication: ## ## #LoginGraceTime 2m ## PermitRootLogin yes ## #StrictModes yes ## #MaxAuthTries 6 ## #MaxSessions 10 ## ## ## ## # Expect .ssh/authorized_keys2 to be disregarded by default in future. ## #AuthorizedKeysFile .ssh/authorized_keys ## ## #AuthorizedPrincipalsFile none ## ## #AuthorizedKeysCommand none ## #AuthorizedKeysCommandUser nobody ## ## # For this to work you will also need host keys in /etc/ssh/ssh_known_hosts ## #HostbasedAuthentication no ## # Change to yes if you don&#39;t trust ~/.ssh/known_hosts for ## # HostbasedAuthentication ## #IgnoreUserKnownHosts no ## # Don&#39;t read the user&#39;s ~/.rhosts and ~/.shosts files ## #IgnoreRhosts yes ## ## # To disable tunneled clear text passwords, change to no here! ## PasswordAuthentication yes ## #PermitEmptyPasswords no ## #PubkeyAuthentication yes ## ## # Change to yes to enable challenge-response passwords (beware issues with ## # some PAM modules and threads) ## ChallengeResponseAuthentication no ## ## # Kerberos options ## #KerberosAuthentication no ## #KerberosOrLocalPasswd yes ## #KerberosTicketCleanup yes ## #KerberosGetAFSToken no ## ## # GSSAPI options ## #GSSAPIAuthentication no ## #GSSAPICleanupCredentials yes ## #GSSAPIStrictAcceptorCheck yes ## #GSSAPIKeyExchange no ## ## # Set this to &#39;yes&#39; to enable PAM authentication, account processing, ## # and session processing. If this is enabled, PAM authentication will ## # be allowed through the ChallengeResponseAuthentication and ## # PasswordAuthentication. Depending on your PAM configuration, ## # PAM authentication via ChallengeResponseAuthentication may bypass ## # the setting of &quot;PermitRootLogin without-password&quot;. ## # If you just want the PAM account and session checks to run without ## # PAM authentication, then enable this but set PasswordAuthentication ## # and ChallengeResponseAuthentication to &#39;no&#39;. ## UsePAM yes ## ## #AllowAgentForwarding yes ## AllowTcpForwarding yes ## #GatewayPorts no ## X11Forwarding yes ## #X11DisplayOffset 10 ## #X11UseLocalhost yes ## #PermitTTY yes ## PrintMotd no ## #PrintLastLog yes ## #TCPKeepAlive yes ## #UseLogin no ## #PermitUserEnvironment no ## #Compression delayed ## #ClientAliveInterval 0 ## #ClientAliveCountMax 3 ## #UseDNS no ## #PidFile /var/run/sshd.pid ## #MaxStartups 10:30:100 ## #PermitTunnel no ## #ChrootDirectory none ## #VersionAddendum none ## ## # no default banner path ## #Banner none ## ## # Allow client to pass locale environment variables ## AcceptEnv LANG LC_* ## ## # override default of no subsystems ## Subsystem sftp /usr/lib/openssh/sftp-server ## ## # Example of overriding settings on a per-user basis ## #Match User anoncvs ## # X11Forwarding no ## # AllowTcpForwarding no ## # PermitTTY no ## # ForceCommand cvs server Al hacer cualquier cambio en este archivo debe reiniciarse el protocolo así: sudo systemctl restart sshd Para conectarse con un servidor debe colocarse ssh y la información del host o ip y el usuario: ssh usuario@hostname shh usuario@ip-address En caso de que la conexión sea através de otro puerto puede especificarse con el parámetro -p. 3.2 SCP (Secure copy protocol) Es un protocolo de transferencia de archivos de forma segura entre un host remoto y uno local, o entre dos ubicaciones remotas. Este funciona desde tu terminal sin haber iniciado o entrado a tu usuario en el servidor. Si estás conectado solo debes poner en tu terminal exit para que se desconecte. Para descargar un archivo desde un servidor o usuario remoto y colocarlo donde estás ubicado actualmente: {bash. eval=FALSE} scp ususario@hostname-or-ipaddres:~/ruta/directorio/archivo.txt . Para subir un archivo a un directorio de tu usuario en el servidor: scp archivo.txt ususario@hostname-or-ipaddres:~/ruta/directorio Para subir un directorio usar siempre -r recursivo: scp -r /ruta/directorio usuario@hostnale-or-ipaddres:/ruta/destino "],["administración-de-usuarios-grupos-y-permisos.html", "4 ADMINISTRACIÓN DE USUARIOS, GRUPOS Y PERMISOS 4.1 USUARIOS 4.2 PERMISOS EN LINUX", " 4 ADMINISTRACIÓN DE USUARIOS, GRUPOS Y PERMISOS 4.1 USUARIOS Existen varios comandos que nos permiten ubicarnos en qué usuario estamos ubicados e incluso en qué sistema operativo operamos y sus características. Por ejemplo este comando te dice que usuario eres: whoami ## yendi Si queremos saber información sobre nuestro sistema, versión, arquitectura y demás: uname -a ## Linux yendi 5.4.0-149-generic #166~18.04.1-Ubuntu SMP Fri Apr 21 16:42:44 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux Ahora, propiamente para conocer la información sobre nuestro usuario, en qué grupo nos encontramos y demás, usamos: id ## uid=1000(yendi) gid=1000(yendi) groups=1000(yendi),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare) uid= identificador de usuario (este será del número 1000 en adelante, los de 1000 para abajo están reservados para el sistema). gid= identificador del grupo principal, cada ususario que creamos puede encontrarse en varios grupos y al crearse por defecto se creará un grupo nuevo (también de 1000 en adelante) a no ser que se indique manualmente este id. groups= grupos a los que pertenece, dependiendo de esto tendrá o no permisos para algunas funciones del sistema. Por ejemplo, aquí el gripo adm indica que tiene privilegios administrativos y sudo que tiene permisos de superusuario, en el caso de CentOS o Alma (red-hat) el grupo wheel tiene privilegios especiales, como la capacidad de ejecutar comandos como superusuario o administrador del sistema. Para revisar los ususarios del sistema y los grupos usamos los siguientes códigos: tail /etc/passwd ## hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false ## geoclue:x:119:124::/var/lib/geoclue:/usr/sbin/nologin ## gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false ## gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false ## yendi:x:1000:1000:yendi,,,:/home/yendi:/bin/bash ## nvidia-persistenced:x:122:127:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin ## rstudio-server:x:999:999::/home/rstudio-server:/bin/sh ## lightdm:x:123:129:Light Display Manager:/var/lib/lightdm:/bin/false ## sshd:x:124:65534::/run/sshd:/usr/sbin/nologin ## dhcpd:x:125:131::/var/run:/usr/sbin/nologin En este vemos el id, gid, el directorio donde estará ubicado y el shell. Para ver los grupos y sus ususarios: tail /etc/group ## gdm:x:125: ## yendi:x:1000: ## sambashare:x:126:yendi ## nvidia-persistenced:x:127: ## rdma:x:128: ## rstudio-server:x:999: ## lightdm:x:129: ## nopasswdlogin:x:130: ## dhcpd:x:131: ## vboxusers:x:132: Hay otros archivos que se instalar con el sistema operativo ubicados en el home (no visibles, así que tienen un . antes del nombre) que pueden ser visualizados y/o modificados según se necesite. .bashrc: Este archivo se ejecuta cada vez que se inicia una nueva sesión de Bash. Contiene configuraciones y variables de entorno personalizadas para el usuario, como alias de comandos, variables de ambiente, configuraciones de color, etc. Cada usuario puede tener su propio archivo .bashrc en su directorio de inicio (~/.bashrc), lo que permite personalizar su entorno de shell. .bash_profile: Es similar a .bashrc, pero se ejecuta solo en el inicio de sesión del usuario (cuando se inicia sesión en el sistema). Se utiliza principalmente para configuraciones y tareas que deben realizarse una vez al iniciar sesión, como cargar variables de entorno, definir rutas, iniciar servicios, etc. Si existe el archivo .bash_profile, Bash lo ejecutará en lugar de .bashrc durante el inicio de sesión. .bash_logout: Este archivo se ejecuta cuando el usuario cierra la sesión. Puede contener comandos o tareas que deben realizarse antes de finalizar la sesión, como guardar el historial de comandos, limpiar temporales, notificar al usuario, etc. .bash_history: Es un archivo que registra el historial de comandos ejecutados por el usuario en el shell de Bash. Cada vez que se ejecuta un comando, se agrega una entrada al archivo .bash_history. Permite al usuario acceder al historial de comandos anteriores utilizando la tecla de flecha hacia arriba o mediante comandos como history. Estos archivos son parte del entorno de configuración y registro de Bash y pueden variar según el sistema operativo y la configuración del usuario. Proporcionan una manera de personalizar y controlar el comportamiento del shell de Bash para adaptarlo a las necesidades del usuario. 4.1.1 CREANDO USUARIOS NUEVOS Creando un usuario con los parámetros por defecto (uid asignado nuevo, gid asignado nuevo, bash y directorio en home con el mismo nombre). sudo useradd usuario1 Crear una contraseña para nuevo usuario sudo passwd usuario1 Creando un nuevo usuario pero con paráemtros establecidos asignadole un -u (userid), -g (gid) -m -d directorio de trabajo y -s un shell. sudo useradd -u 2000 -g 1000 -m -d /home/usuario2 -s /bin/bash usuario2 Crear un usuario para un proceso pero sin acceso. sudo useradd -s /sbin/nologin usuario3 Creando un usuario nuevo asignadolo a un grupo sudo useradd -G wheel usuario4 4.1.2 MODIFICANDO CUENTAS DE USUARIO Cambiar el directorio de un usuario sudo usermod -m -d /home/user1 usuario1 Cambiar el shell de un usuario sudo usermod -s /sbin/nologin/ usuario2 Cambiar el login name de un usuario sudo usermod -l user2 usuario2 Agregar adicionalmente un usuario a un grupo ya definido (sin sacarlo de los grupos donde se encuentre) sudo usermod -a -G 1000 usuario6 Asignar un nuevo grupo principal a un usuario (ojo! el grupo se conservará pero el usuario ya no estará en ese grupo). sudo usermod -g 1000 usuario3 Eliminar un grupo (vacío) sudo groupdel usuario3 Eliminar un usuario sudo userdel usuario4 Remover un usuario de un grupo en específico sudo gpasswd -d usuario5 admon Con los codigos vistos previamente podemos estar seguros de los cambios previamente realizados: tail /cat/etc/passwd tail /cat/etc/group 4.2 PERMISOS EN LINUX Los permisos constan de una cadena de 9 caracteres, de los cuales, los 3 primeros son permisos de usuario actual, los 3 siguientes los permisos de los usuario pertenecientes al mismo grupo del usuario actual y los tres últimos los permisos para todos los usuarios. Este se hace con el código chmod . Los pérmisos pueden ser de: r = reading (lectura, apertura de archivos y directorios) w = writting (escritura, modficiación de archivos) x = executing (ejecución, poner en marcha programas) Existen dos métodos para administrar permisos: un método numérico y otro simbólico. 4.2.1 Método numérico r w x código numérico 0 0 0 0 0 0 1 1 0 1 0 2 0 1 1 3 1 0 0 4 1 0 1 5 1 1 0 6 1 1 1 7 Entonces si utilizas el número 7 estarás concediendo permiso de lectura, escritura y ejecución a quién lo desees. Ejemplo: chmod 777 . En este ejemplo estás dando permiso de los tres tipos a todos los usuarios (ususario actual, grupos y otros) del directorio actual. chmod 750 . En este ejemplo estás dando permiso de los tres tipos a todos los usuarios del directorio actual al usuario actual, permiso de lectura y ejecución a los del mismo grupo y ningún permiso a otro usuario externo. 4.2.2 Método simbólico Para este método se usará g para grupos, o para otros y a para todos , + si es permiso concedido y - si es denegado. Por ejemplo, queremos darle permiso del presente directorio a los ususario de migrupo, permisos de lectura y ejecución: chmod g+rx o darselo a otros: chmod o+rx o remover permisos a los de tu grupo y a otros: chmod g-rw,o-r o a todos: a-rwx "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
